/*

 Jason Davis - 2005 | mohadib@openactive.org 

 jerklib.InternalIRCEventParser

 This file is part of JerkLib Java IRC Library.

 JerkLib is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 JerkLib is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with GenricPlayer; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 

 */

package jerklib;

import jerklib.ServerInformation.ModeType;
import jerklib.events.*;
import jerklib.events.impl.ModeEventImpl;
import jerklib.events.impl.NickChangeEventImpl;
import jerklib.events.impl.ServerInformationEventImpl;
import jerklib.events.impl.TopicEventImpl;
import jerklib.events.impl.WhoisEventImpl;
import jerklib.tokens.EventToken;
import jerklib.tokens.Token;

import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

/**
 * InternalEventParser is the first place IRCEvents are sent. Here they are
 * parsed and made into more specific events then re-dispachted to any listeners
 * via the ConnectionManager. <p/> This class is mostly convience for users of
 * the lib , however some internal stuff depends on this class as well. Like
 * keeping track of nicks in a channel or knowing when a connection is ready to
 * join channels etc. <p/> Thanks to Gracenotes for the help
 * 
 * @author mohadib
 */
class InternalEventParserImpl implements InternalEventParser
{
	private ConnectionManager manager;
	private Map<Channel, TopicEvent> topicMap = new HashMap<Channel, TopicEvent>();
	private WhoisEventImpl we;
	Logger log = Logger.getLogger(this.getClass().getName());

	public InternalEventParserImpl(ConnectionManager manager)
	{
		this.manager = manager;
	}

	/**
	 * Takes an IRCEvent and tries to parse it into a more specific event then
	 * redispatch the more specfic event.
	 * 
	 * @param event
	 *          <code>IRCEvent</code> the event to parse
	 */
	public void parseEvent(IRCEvent event)
	{
		Session session = event.getSession();
		String data = event.getRawEventData();
		String nick = session.getNick();
		
		EventToken eventToken = new EventToken(data);
		List<Token> tokens = eventToken.getWordTokens();
		if (tokens.isEmpty()) return;

		String command = tokens.get(1).data;
		
		if (command.matches("^\\d{3}$"))
		{
			numericEvent(eventToken, session, event, Integer.parseInt(command));
		}
		else if (command.equals("PRIVMSG"))
		{
			message(eventToken, session);
		}
		else if (command.equals("QUIT"))
		{
			QuitEvent qEvent = IRCEventFactory.quit(eventToken, session);
			session.removeNickFromAllChannels(qEvent.getNick());
			manager.addToRelayList(qEvent);
		}
		else if (command.equals("JOIN"))
		{
			if (IRCEventFactory.getNick(tokens.get(0)).equalsIgnoreCase(nick))
			{
				Channel channel = new Channel(tokens.get(2).data.replaceFirst(":", "").toLowerCase(), session);
				session.addChannel(channel);
				manager.addToRelayList(IRCEventFactory.joinCompleted(data, session, nick, channel));
			}
			else
			{
				System.out.println(eventToken.getData());
				JoinEvent jEvent = IRCEventFactory.regularJoin(eventToken, session);
				jEvent.getChannel().addNick(jEvent.getNick());
				manager.addToRelayList(jEvent);
			}
		}
		else if (command.equals("MODE"))
		{
			mode(event , eventToken);
		}
		else if (command.equals("PART"))
		{
			PartEvent pEvent = IRCEventFactory.part(eventToken, session);
			if (!pEvent.getChannel().removeNick(pEvent.getWho()))
			{
				log.severe("Could Not remove nick " + pEvent.getWho() + " from " + pEvent.getChannelName());
			}
			if (pEvent.getWho().equalsIgnoreCase(nick))
			{
				session.removeChannel(pEvent.getChannel());
			}
			manager.addToRelayList(pEvent);
		}
		else if (command.equals("NOTICE"))
		{
			manager.addToRelayList(IRCEventFactory.notice(eventToken, session));
		}
		else if (command.equals("TOPIC"))
		{
			Pattern p = Pattern.compile("^.+?TOPIC\\s+(.+?)\\s+.*$");
			Matcher m = p.matcher(data);
			m.matches();
			event.getSession().sayRaw("TOPIC " + m.group(1));
		}
		else if (command.equals("INVITE"))
		{
			manager.addToRelayList(IRCEventFactory.invite(data, session));
		}
		else if (command.equals("NICK"))
		{
			NickChangeEvent nEvent = IRCEventFactory.nickChange(eventToken , session);
			session.nickChanged(nEvent.getOldNick(), nEvent.getNewNick());
			if (nEvent.getOldNick().equals(nick))
			{
				event.getSession().updateProfileSuccessfully(true);
			}
			manager.addToRelayList(nEvent);
		}
		else if (command.equals("KICK"))
		{
			KickEvent ke = IRCEventFactory.kick(eventToken, session);
			if (!ke.getChannel().removeNick(ke.getWho()))
			{
				log.info("COULD NOT REMOVE NICK " + ke.getWho() + " from channel " + ke.getChannel().getName());
			}

			if (ke.getWho().equals(nick))
			{
				session.removeChannel(ke.getChannel());
				if (session.isRejoinOnKick())
				{
					session.join(ke.getChannel().getName());
				}
			}
			manager.addToRelayList(ke);
		}
		else if (data.matches("^NOTICE\\s+(.*$)$"))
		{
			manager.addToRelayList(IRCEventFactory.notice(eventToken, session));
		}
		else if (data.matches("^PING.*"))
		{
			session.getConnection().pong(event);
			manager.addToRelayList(event);
		}
		else if (data.matches(".*PONG.*"))
		{
			session.getConnection().gotPong();
			manager.addToRelayList(event);
		}
		else
		{
			manager.addToRelayList(event);
		}
	}

	// :kubrick.freenode.net 324 mohadib__ #test +mnPzlfJ 101 #flood 1,2
	// :swiftco.wa.us.dal.net 324 mohadib #Testing +tn 
	private void channelMode(IRCEvent event)
	{
		Pattern p = Pattern.compile("^\\S+\\s+\\S+\\s+\\S+\\s+(\\S+)\\s+(.+)$");
		Matcher m = p.matcher(event.getRawEventData());
		if(m.matches())
		{
			event.getSession().getChannel(m.group(1)).setModeString(m.group(2));
			ModeEvent me = new ModeEventImpl(event.getRawEventData(), event.getSession(), null, null, event.getSession().getChannel(m.group(1)));
			manager.addToRelayList(me);
		}
		else
		{
			//no arguments
			p = Pattern.compile("^\\S+\\s+\\S+\\s+\\S+\\s+(\\S+)$");
			m = p.matcher(event.getRawEventData());
			ModeEvent me = new ModeEventImpl(event.getRawEventData(), event.getSession(), null, null, event.getSession().getChannel(m.group(1)));
		}
	}

	
	// :mohadib_!n=mohadib@unaffiliated/mohadib MODE #jerklib +o scripyasas
	// :services. MODE mohadib :+e
	private void mode(IRCEvent event , EventToken token)
	{
		if (log.isLoggable(Level.FINE))log.fine(token.getData());
		
		List<Token> wordTokens = token.getWordTokens(); 
		char[] modeTokens = wordTokens.get(3).data.replaceFirst(":" , "").toCharArray();
		String[] arguments = token.concatTokens(8).split("\\s+");

		Map<String, List<String>> modeMap = new HashMap<String, List<String>>();
		ServerInformation info = event.getSession().getServerInformation();
		
		/* see if user mode */
		boolean channelMode = event.getSession().isChannelToken(wordTokens.get(2));

		char action = '+';
		
		if (!channelMode)
		{
			if (log.isLoggable(Level.INFO))log.info("MODE  " + Arrays.toString(modeTokens));

			List<String> targets = new ArrayList<String>();
			targets.add(event.getSession().getNick());
			for (char mode : modeTokens)
			{
				if (mode == '+' || mode == '-')
				{
					action = mode;
				}
				else
				{
					modeMap.put(action + "" +  mode, targets);
				}
			}

			//remove : and . -> :services.
			String who = wordTokens.get(0).data.replaceFirst(":" , "");
			if(who.endsWith("."))who = who.substring(0 , who.length() - 1);
			
			ModeEvent me = new ModeEventImpl
			(
				token.getData(), 
				event.getSession(), 
				modeMap, 
				who,
				null
			);

			manager.addToRelayList(me);
			return;
		}

		int argumntOffset = 0;
		
		for (char mode : modeTokens)
		{
			if (mode == '+' || mode == '-')
			{
				action = mode;
			}	
			else
			{
				ModeType type = info.getTypeForMode(String.valueOf(mode));
				// must have an argument on + and -
				if (type == ModeType.GROUP_A || type == ModeType.GROUP_B)
				{
					List<String> modeArgs = modeMap.get(action +""+ mode);
					if (modeArgs == null)modeArgs = new ArrayList<String>();
					modeArgs.add(arguments[argumntOffset]);
					argumntOffset++;
					modeMap.put(action + "" + mode, modeArgs);
				}
				// must have args on + , must not have args on -
				else if (type == ModeType.GROUP_C)
				{
					List<String> modeArgs = modeMap.get(action +""+ mode);
					if (modeArgs == null)modeArgs = new ArrayList<String>();
					if (action == '-')
					{
						if (!modeMap.containsKey(action +""+ mode))
						{
							modeMap.put(action + "" + mode, new ArrayList<String>());
						}
					}
					else
					{
						modeArgs.add(arguments[argumntOffset]);
						argumntOffset++;
						modeMap.put(action +""+ mode, modeArgs);
					}
				}
				// no args
				else if (type == ModeType.GROUP_D)
				{
					modeMap.put(action +""+ mode, new ArrayList<String>());
				}
				else
				{
					System.err.println("unreconzied mode " + mode);
				}
			}
		}
		
		// update user modes in channel
		Channel chan = event.getSession().getChannel(wordTokens.get(2).data);
		for(String mode : modeMap.keySet())
		{
			List<String>nicks = modeMap.get(mode);
			for(String nick : nicks)
			{
				if(chan.getNicks().contains(nick))
				chan.updateUsersMode(nick, mode);
			}
		}
		
		ModeEvent me = new ModeEventImpl(event.getRawEventData(), event.getSession(), modeMap, IRCEventFactory.getNick(wordTokens.get(0)), chan);

		manager.addToRelayList(me);
	}

	
	
	
	
	/*
	 * :kubrick.freenode.net 311 scripy mohadib n=fran unaffiliated/mohadib *
	 * :fran :kubrick.freenode.net 319 scripy mohadib :#jerklib
	 * :kubrick.freenode.net 312 scripy mohadib irc.freenode.net
	 * :http://freenode.net/ :kubrick.freenode.net 320 scripy mohadib :is
	 * identified to services :kubrick.freenode.net 318 scripy mohadib :End of
	 * /WHOIS list.
	 */
	private void whois(EventToken token, Session session, int numeric)
	{
		switch (numeric)
		{
		case 311:
		{
			// "<nick> <user> <host> * :<real name>"
			we = (WhoisEventImpl) IRCEventFactory.whois(token, session);
			break;
		}
		case 319:
		{
			// "<nick> :{[@|+]<channel><space>}"
			// :kubrick.freenode.net 319 scripy mohadib :@#jerklib
			// kubrick.freenode.net 319 scripy mohadib :@#jerklib ##swing
			Pattern p = Pattern.compile("^:\\S+\\s\\d{3}\\s\\S+\\s\\S+\\s:(.*)$");
			Matcher m = p.matcher(token.getData());
			if (we != null && m.matches())
			{
				List<String> chanNames = Arrays.asList(m.group(1).split("\\s+"));
				we.setChannelNamesList(chanNames);
				we.appendRawEventData(token.getData());
			}
			break;
		}
			// "<nick> <server> :<server info>"
			// :kubrick.freenode.net 312 scripy mohadib irc.freenode.net
			// :http://freenode.net/
		case 312:
		{
			Pattern p = Pattern.compile("^:\\S+\\s\\d{3}\\s\\S+\\s\\S+\\s(\\S+)\\s:(.*)$");
			Matcher m = p.matcher(token.getData());
			if (we != null && m.matches())
			{
				we.setWhoisServer(m.group(1));
				we.setWhoisServerInfo(m.group(2));
				we.appendRawEventData(token.getData());
			}
			break;
		}
			// not in RFC1459
			// :kubrick.freenode.net 320 scripy mohadib :is identified to services
		case 320:
		{
			Pattern p = Pattern.compile("^:\\S+\\s\\d{3}\\s\\S+\\s(\\S+)\\s:(.*)$");
			Matcher m = p.matcher(token.getData());
			if (we != null && m.matches())
			{
				// System.out.println("nick idented: " + m.group(1) + " " + m.group(2));
				we.appendRawEventData(token.getData());
			}
			break;
		}
			// :anthony.freenode.net 317 scripy scripy 2 1202063240 :seconds idle,
			// signon time
			// from rfc "<nick> <integer> :seconds idle"
		case 317:
		{
			Pattern p = Pattern.compile("^:\\S+\\s\\d{3}\\s\\S+\\s\\S+\\s+(\\d+)\\s+(\\d+)\\s+:.*$");
			Matcher m = p.matcher(token.getData());
			if (we != null && m.matches())
			{
				we.setSignOnTime(Integer.parseInt(m.group(2)));
				we.setSecondsIdle(Integer.parseInt(m.group(1)));
			}
		}
		case 318:
		{
			// end of whois - fireevent
			if (we != null)
			{
				we.appendRawEventData(token.getData());
				manager.addToRelayList(we);
				we = null;
			}
			break;
		}
		default:
			log.info(token.getData());
			break;
		}
	}

	private void serverInfo(EventToken token, IRCEvent event)
	{
		Session session = event.getSession();
		session.getServerInformation().parseServerInfo(token.getData());
		ServerInformationEventImpl se = new ServerInformationEventImpl(session, token.getData(), session.getServerInformation());
		manager.addToRelayList(se);
	}

	private void numericEvent(EventToken token, Session session, IRCEvent event, int numeric)
	{
		switch (numeric)
		{
			case 001:connectionComplete(token, session, event);break;
			case 002:manager.addToRelayList(IRCEventFactory.serverVersion(token, session));break;
			case 005:
				serverInfo(token, event);
				break;
			case 301:
				manager.addToRelayList(IRCEventFactory.away(token.getData(), session, numeric));
				break;
			case 305:
				manager.addToRelayList(IRCEventFactory.away(token.getData(), session, numeric));
				break;
			case 306:
				manager.addToRelayList(IRCEventFactory.away(token.getData(), session, numeric));
				break;
			case 314:
				manager.addToRelayList(IRCEventFactory.whowas(token, session));
				break;
			case 311:// whois
			case 312:// whois
			case 317:// whois
			case 318:// whois
			case 319:// whois
			case 320:
				whois(token, event.getSession(), numeric);
				break;
			case 321:
				break;// chanlist
			case 322:
				manager.addToRelayList(IRCEventFactory.chanList(token, session));
				break;
			case 323:
				break; // end chan ist
			case 324:
				channelMode(event);
				break;
			case 332:topic(token, session , numeric);break;
			case 333:topic(token, session , numeric);break;
			case 351:
				manager.addToRelayList(IRCEventFactory.serverVersion(token, session));
				break;
			case 352:
				manager.addToRelayList(IRCEventFactory.who(token, session));
				break;
			case 353:
				namesLine(token, session);
				manager.addToRelayList(event);
				break;
			case 366:
				manager.addToRelayList(IRCEventFactory.nickList(token, session));
				break;
			case 372:// motd
			case 375:// motd
			case 376:
				manager.addToRelayList(IRCEventFactory.motd(token, session));
				break;
			case 433:
				nick(token, session);
				break;
			case 401:
			case 402:
			case 403:
			case 404:
			case 405:
			case 406:
			case 407:
			case 409:
			case 411:
			case 412:
			case 413:
			case 414:
			case 421:
			case 422:
			case 423:
			case 424:
			case 431:
			case 432:
			case 436:
			case 441:
			case 442:
			case 443:
			case 444:
			case 445:
			case 446:
			case 451:
			case 461:
			case 462:
			case 463:
			case 464:
			case 465:
			case 467:
			case 471:
			case 472:
			case 473:
			case 474:
			case 475:
			case 481:
			case 482:
			case 483:
			case 491:
			case 501:
			case 502:
				manager.addToRelayList(IRCEventFactory.numericError(token, session, numeric));
				break;
			default:
				manager.addToRelayList(event);
		}
	}
	
	//:sterling.freenode.net 332 scrip #test :Welcome to #test - This channel is for testing only
	//:sterling.freenode.net 333 scrip #test LuX 1159267246
	private void topic(EventToken token, Session session , int numeric)
	{
		if(numeric == 332)
		{
			TopicEvent tEvent = IRCEventFactory.topic(token, session);
			if (topicMap.containsValue(tEvent.getChannel()))
			{
				((TopicEventImpl) topicMap.get(tEvent.getChannel())).appendToTopic(tEvent.getTopic());
			}
			else
			{
				topicMap.put(tEvent.getChannel(), tEvent);
			}
		}
		else
		{
			Pattern p = Pattern.compile(":(\\S+)\\s+333\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)$");
			Matcher m = p.matcher(token.getData());
			m.matches();
			Channel chan = (Channel) session.getChannel(m.group(3));
			if (topicMap.containsKey(chan))
			{
				TopicEventImpl tEvent = (TopicEventImpl) topicMap.get(chan);
				topicMap.remove(chan);
				tEvent.setSetBy(m.group(4));
				tEvent.setSetWhen(m.group(5));
				chan.setTopicEvent(tEvent);
				manager.addToRelayList(tEvent);
			}
		}
	}

	Random rand = new Random();

	private void nick(EventToken token, Session session)
	{
		/* NICK IN USE */
		// :simmons.freenode.net 433 * fran :Nickname is already in use.
		if (session.isConnected() && session.isProfileUpdating())
		{
			session.updateProfileSuccessfully(false);
		}

		if (!session.getConnection().loggedInSuccessfully())
		{
			Profile p = session.getRequestedConnection().getProfile();
			String aNick = p.getActualNick();
			String newNick = p.getFirstNick() + rand.nextInt(100);
			if (aNick.equals(p.getFirstNick()))
			{
				newNick = p.getSecondNick();
			}
			else if (aNick.equals(p.getSecondNick()))
			{
				newNick = p.getThirdNick();
			}
			((ProfileImpl) p).setActualNick(newNick);
			session.changeProfile(p);
		}

		manager.addToRelayList(IRCEventFactory.nickInUse(token, session));
	}

	private void connectionComplete(EventToken token, Session session, IRCEvent event)
	{
		/* sometimes the server will change the nick when connecting
		 * for instance , if the nick is too long it will be trunckated
		 * need to check if this happend and send a nick update event
		 */
		
		String nick = token.getWordTokens().get(2).data;
		String profileNick = session.getNick();
		if(!nick.equalsIgnoreCase(profileNick))
		{
			ProfileImpl pi = (ProfileImpl)session.getRequestedConnection().getProfile();
			pi.setActualNick(nick);
			NickChangeEvent nce = new NickChangeEventImpl
			(
				token.getData(),
				session,
				profileNick,
				nick,
				"",
				""
			);
			manager.addToRelayList(nce);
		}
		
		ConnectionCompleteEvent ccEvent = IRCEventFactory.connectionComplete(token, session);
		session.getConnection().loginSuccess();
		session.getConnection().setHostName(ccEvent.getActualHostName());
		manager.addToRelayList(ccEvent);
	}

	private void message(EventToken token, Session session)
	{
		MessageEvent me = IRCEventFactory.message(token , session);

		String msg = me.getMessage();
		if (msg.startsWith("\u0001"))
		{
			String ctcpString = msg.substring(1, msg.length() - 1);
			me = IRCEventFactory.ctcp(me, ctcpString);
		}
		manager.addToRelayList(me);
	}

	private void namesLine(EventToken token, Session session)
	{
		Pattern p = Pattern.compile("^:(?:.+?)\\s+353\\s+\\S+\\s+(?:=|@)\\s+(\\S+)\\s:(.+)$");
		Matcher m = p.matcher(token.getData());
		if (m.matches())
		{
			Channel chan = session.getChannel(m.group(1));
			String[] names = m.group(2).split("\\s+");

			for (String name : names)
			{
				if (name != null && name.length() > 0)
				{
					chan.addNick(name);
				}
			}
		}
	}

}









package jerklib;

import jerklib.events.*;
import jerklib.events.IRCEvent.Type;
import jerklib.events.impl.*;
import jerklib.tokens.EventToken;
import jerklib.tokens.Token;

import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class IRCEventFactory
{
	private static ConnectionManager myManager;

	static void setManager(ConnectionManager manager)
	{
		myManager = manager;
	}

	//"<version>.<debuglevel> <server> :<comments>"
	// :kubrick.freenode.net 351 scripy hyperion-1.0.2b(382). kubrick.freenode.net :iM dncrTS/v4
	// :kubrick.freenode.net 002 mohadib_ :Your host is kubrick.freenode.net[kubrick.freenode.net/6667], running version hyperion-1.0.2b
	// :irc.nixgeeks.com 002 mohadib :Your host is irc.nixgeeks.com, running version Unreal3.2.3
	static ServerVersionEvent serverVersion(EventToken token, Session session)
	{
		List<Token> tokens = token.getWordTokens();
		
		Token numeric = tokens.get(1);
		if(numeric.data.equals("002"))
		{
			return new ServerVersionEventImpl
			(
				"",
				tokens.get(6).data,
				tokens.get(9).data,
				"",
				token.getData(),
				session
			);
		}
		
		
			return new ServerVersionEventImpl
			(
				token.concatTokens(10).substring(1), 
				tokens.get(5).data,
				tokens.get(4).data, 
				"", 
				token.getData(), 
				session
			);
	}

	// :irc.nmglug.org 001 namnar :Welcome to the nmglug.org
	public static ConnectionCompleteEvent connectionComplete(EventToken token, IRCEvent event)
	{
			List<Token> tokens = token.getWordTokens();
			/* send host name changed event so users of lib can update *records* */
			return new ConnectionCompleteEventImpl
			(
					token.getData(), 
					tokens.get(0).data.substring(1).toLowerCase(), // new
					event.getSession(), 
					event.getSession().getConnection().getHostName() // old hostname
			);
	}

	// :simmons.freenode.net 352 r0bby_ * n=wakawaka guifications/user/r0bby
	// irc.freenode.net r0bby H :0 Robert O'Connor
	static WhoEvent who(EventToken token, Session session)
	{
		String data = token.getData();
		Pattern p = Pattern.compile("^:.+?\\s+352\\s+.+?\\s+(.+?)\\s+(.+?)\\s+(.+?)\\s+(.+?)\\s+(.+?)\\s+(.+?):(\\d+)\\s+(.+)$");
		Matcher m = p.matcher(data);
		if (m.matches())
		{
			
			boolean away = m.group(6).charAt(0) == 'G';
			return new WhoEventImpl(m.group(1), // channel
					Integer.parseInt(m.group(7)), // hop count
					m.group(3), // hostname
					away, // status indicator
					m.group(5), // nick
					data, // raw event data
					m.group(8), // real name
					m.group(4), // server name
					session, // session
					m.group(2) // username
			);
		}
		debug("WHO", data);
		return null;
	}

	// :kubrick.freenode.net 314 scripy1 ty n=ty 71.237.206.180 * :ty
	// "<nick> <user> <host> * :<real name>"
	static WhowasEvent whowas(EventToken token, Session session)
	{
		List<Token> tokens = token.getWordTokens();
			return new WhowasEventImpl
			(
					tokens.get(5).data, 
					tokens.get(4).data, 
					tokens.get(3).data, 
					tokens.get(tokens.size() -1).data.substring(1), 
					token.getData(), 
					session
			); 
	}

	static NumericErrorEvent numericError(EventToken token, Session session, int numeric)
	{
		return new NumericEventImpl
		(
				token.concatTokens(7), 
				token.getData(), 
				numeric, 
				session
		); 
	}

	static WhoisEvent whois(EventToken token, Session session)
	{
		// "<nick> <user> <host> * :<real name>"
			List<Token> tokens = token.getWordTokens();
			return new WhoisEventImpl
			(	
					tokens.get(4).data, 
					token.getData().substring(token.getData().lastIndexOf(":") + 1), 
					tokens.get(5).data, 
					tokens.get(6).data, 
					token.getData(), 
					session
			); 
	}

	/*
	 * end of names :irc.newcommunity.tummy.com 366 SwingBot #test :End of NAMES
	 * list
	 */
	static NickListEvent nickList(EventToken token, Session session)
	{
			List<Token>tokens = token.getWordTokens();
			return new NickListEventImpl
			(
					token.getData(), 
					session, 
					session.getChannel(tokens.get(3).data), 
					session.getChannel(tokens.get(3).data).getNicks()
			); 
	}

	/* :mohadib!~mohadib@67.41.102.162 KICK #test scab :bye! */
	public static KickEvent kick(EventToken token, IRCEvent event)
	{
		Session session = event.getSession();
		List<Token>tokens = token.getWordTokens();
			Channel channel = session.getChannel(tokens.get(2).data);
			return new KickEventImpl
			(
					token.getData(), 
					session, 
					getNick(tokens.get(0)), // byWho
					getUserName(tokens.get(0)), // username
					getHostName(tokens.get(0)), // host name
					tokens.get(3).data, // victim
					token.concatTokens(8).substring(1), // message
					channel
			);
	}

	// sterling.freenode.net 332 scrip #test :Welcome to #test - This channel is
	// for testing only.
	static TopicEvent topic(EventToken token, Session session)
	{
			List<Token> tokens = token.getWordTokens();
			return new TopicEventImpl
			(
					token.getData(), 
					session, 
					session.getChannel(tokens.get(3).data),
					token.concatTokens(8).substring(1)
			);
	}

	/*
	 * A Channel Msg :fuknuit!~admin@212.199.146.104 PRIVMSG #debian :blah blah
	 * Private message :mohadib!~mohadib@67.41.102.162 PRIVMSG SwingBot :HY!!
	 */
	public static MessageEvent message(EventToken token , IRCEvent event)
	{
		List<Token>tokens = token.getWordTokens();
		Session session = event.getSession();
		Type type = session.isChannelToken(tokens.get(2))?Type.CHANNEL_MESSAGE:Type.PRIVATE_MESSAGE;
		Channel chan = type == Type.CHANNEL_MESSAGE? session.getChannel(tokens.get(2).data):null;
		return new MessageEventImpl
		(
			chan,
			getHostName(tokens.get(0)), 
			token.concatTokens(6).substring(1), 
			getNick(tokens.get(0)),
			token.getData(), 
			session, 
			type, 
			getUserName(tokens.get(0))
		);
	}
	
	static String getHostName(Token t)
	{
		return t.data.substring(t.data.indexOf('@') + 1);
	}

	static String getUserName(Token t)
	{
		return t.data.substring(t.data.indexOf('!') + 1 , t.data.indexOf('@'));
	}
	
	static String getNick(Token t)
	{
		if(t.data.indexOf("!") != -1)
		{
			return t.data.substring(1).substring(0,t.data.indexOf('!') - 1);
		}
		return t.data.substring(1);
	}


	public static CtcpEvent ctcp(MessageEvent event, String ctcpString)
	{
		if (ctcpString.startsWith("DCC "))
		{
			return DccEventFactory.dcc(event, ctcpString);
		}
		else
		{
			return new CtcpEventImpl(ctcpString, event.getHostName(), event.getMessage(), event.getNick(), event.getUserName(), event.getRawEventData(), event.getChannel(), event.getSession());
		}

	}
	
	// the_horrible is the nick that is in use
	// fran is the current nickname
	/* :simmons.freenode.net 433 fran the_horrible :Nickname is already in use. */

	// * is used for current nick when this event happens on connect
	/* :simmons.freenode.net 433 * fran :Nickname is already in use. */

	static NickInUseEvent nickInUse(EventToken token, Session session)
	{
			List<Token> tokens = token.getWordTokens();
			String nick = tokens.get(2).data.equals("*")?tokens.get(3).data:tokens.get(2).data;
			return new NickInUseEventImpl
			(
					nick,
					token.getData(), 
					session
			); 
	}

	// :leguin.freenode.net 306 r0bby_ :You have been marked as being away
	// :leguin.freenode.net 305 r0bby_ :You are no longer marked as being away
	static AwayEvent away(String data, Session session, int numeric)
	{
		Pattern p = Pattern.compile("^:\\S+\\s\\d{3}\\s+(\\S+)\\s:(.*)$");
		Matcher m = p.matcher(data);
		if (m.matches())
		{
			switch (numeric)
			{
			case 305:
				return new AwayEventImpl(session, AwayEvent.EventType.RETURNED_FROM_AWAY, false, true, myManager.getDefaultProfile().getActualNick(), data);
			case 306:
			{
				return new AwayEventImpl(session, AwayEvent.EventType.WENT_AWAY, true, true, myManager.getDefaultProfile().getActualNick(), data);
			}
			}
		}
		// :card.freenode.net 301 r0bby_ r0bby :foo
		p = Pattern.compile("^:\\S+\\s+\\d{3}\\s+\\S+\\s+(\\S+)\\s+:(.*)$");
		m = p.matcher(data);
		m.matches();
		return new AwayEventImpl(m.group(2), AwayEvent.EventType.USER_IS_AWAY, true, false, m.group(1), data, session);
	}

	// :anthony.freenode.net 375 mohadib_ :- anthony.freenode.net Message of the Day -
	// :anthony.freenode.net 372 mohadib_ :- Welcome to anthony.freenode.net in Irvine, CA, USA! Thanks to
	// :anthony.freenode.net 376 mohadib_ :End of /MOTD command.
	static MotdEvent motd(EventToken token , Session session)
	{
		List<Token>tokens = token.getWordTokens();
		return new MotdEventImpl
		(
			token.getData(), 
			session, 
			token.concatTokens(6).substring(1), 
			tokens.get(0).data.substring(1)
		);
	}

	public static NoticeEvent notice(EventToken token, IRCEvent event)
	{
		
		final List<Token> tokens = token.getWordTokens();
		Session session = event.getSession();
		// generic notice NOTICE AUTH :*** No identd (auth) response
		if(tokens.get(0).data.equals("NOTICE"))
		{
			return new NoticeEventImpl
			(
				token.getData(), 
				session, 
				"generic", 
				token.substring(token.getData().indexOf(":") + 1), 
				session.getNick(), 
				session.getConnectedHostName(),
				null
			);
		}
		
		if(tokens.get(1).data.equals("NOTICE"))
		{
			//from server to user
			//:anthony.freenode.net NOTICE mohadib_ :NickServ set your hostname to foo
			if(tokens.get(0).data.indexOf("@") == -1)
			{
				return new NoticeEventImpl
				(
					token.getData(), 
					session, 
					"server", 
					token.substring(token.getData().indexOf(":" , 1) + 1), 
					session.getNick(), 
					session.getConnectedHostName(), 
					null
				);
			}
			
			//from user to channel
			// channel notice :DIBLET!n=fran@c-68-35-11-181.hsd1.nm.comcast.net NOTICE #jerklib :test
			if(session.isChannelToken(tokens.get(2)))
			{
				Channel channel = session.getChannel(tokens.get(2).data);
				return new NoticeEventImpl
				(
						token.getData(),
						session,
						"channel",
						token.getData().substring(token.getData().indexOf(":", 1) + 1),
						channel.getName(),
						getNick(tokens.get(0)),
						channel
				);
			}
			else
			{
				//:NickServ!NickServ@services. NOTICE mohadib_ :This nickname is owned by someone else
				return new NoticeEventImpl
				(
						token.getData(),
						session,
						"user",
						token.getData().substring(token.getData().indexOf(":", 1) + 1),
						session.getNick(),
						getNick(tokens.get(0)),
						null
				);
			}
		}
		
		return null;
	}

	// TODO
	// :anthony.freenode.net 391 scripy anthony.freenode.net :Monday February 4
	// 2008 -- 18:02:31 -08:00
	static void ServerTimeEvent()
	{

	}

	/*
	 * :r0bby__!n=wakawaka@cpe-24-164-167-171.hvc.res.rr.com QUIT :Client Quit
	 * PERSON QUIT :Xolt!brad@c-67-165-231-230.hsd1.co.comcast.net QUIT :"Deleted"
	 * :james_so!~me@213-152-46-35.dsl.eclipse.net.uk QUIT :Read error: 60
	 * (Operation timed out)
	 */
	public static QuitEvent quit(EventToken token, IRCEvent event)
	{
		List<Token>tokens = token.getWordTokens();
		Session session = event.getSession();
		String nick = getNick(tokens.get(0));
		List<Channel> chanList = session.removeNickFromAllChannels(nick);
		return new QuitEventImpl
		(
			token.getData(), 
			session, 
			nick, // who
			getUserName(tokens.get(0)), // username
			getHostName(tokens.get(0)), // hostName
			token.concatTokens(4).substring(1), // message
			chanList
		);
	}

	// :r0bby!n=wakawaka@guifications/user/r0bby JOIN :#jerklib
	// :mohadib_!~mohadib@68.35.11.181 JOIN &test
	public static JoinEvent regularJoin(EventToken token, IRCEvent event)
	{
				List<Token> tokens = token.getWordTokens();
				Session session = event.getSession();
				return new JoinEventImpl
				(
					token.getData(), 
					session, 
					getNick(tokens.get(0)), // nick
					getUserName(tokens.get(0)), // user name
					getHostName(tokens.get(0)), // host
					tokens.get(2).data.replaceFirst(":", ""), // channel name
					session.getChannel(tokens.get(2).data.replaceFirst(":", "")) // channel
				);
	}

	/*
	 * :anthony.freenode.net 322 mohadib_ #jerklib 5 :JerkLib IRC Library -
	 * https://sourceforge.net/projects/jerklib :irc.nixgeeks.com 321 mohadib
	 * Channel :Users Name
	 */
	static ChannelListEvent chanList(EventToken token, Session session)
	{
		String data = token.getData();
		if (log.isLoggable(Level.FINE))
		{
			log.fine(data);
		}
		Pattern p = Pattern.compile("^:\\S+\\s322\\s\\S+\\s(\\S+)\\s(\\d+)\\s:(.*)$");
		Matcher m = p.matcher(data);
		if (m.matches()) { return new ChannelListEventImpl(data, m.group(1), m.group(3), Integer.parseInt(m.group(2)), session); }
		debug("CHAN_LIST", data);
		return null;
	}

	public static JoinCompleteEvent joinCompleted(JoinEvent je)
	{
		return new JoinCompleteEventImpl(je.getRawEventData(), je.getSession(), je.getChannel());
	}

	// :fran!~fran@outsiderz-88006847.hsd1.nm.comcast.net PART #jerklib
	// :r0bby!n=wakawaka@guifications/user/r0bby PART #jerklib :"FOO"
	// :mohadib_!~mohadib@68.35.11.181 PART :&test
	// :AlbCMCSG!jenna@stop.t.o.shit.la PART #cod4.wars
	public static PartEvent part(EventToken token , IRCEvent event)
	{
		Session session = event.getSession();
		List<Token>tokens = token.getWordTokens();
			String partMsg = tokens.size() >= 4?token.concatTokens(6).substring(1):"";
			if(tokens.get(2).data.startsWith(":"))tokens.get(2).data = tokens.get(2).data.substring(1);
			return new PartEventImpl
			(
					token.getData(), 
					session,
					getNick(tokens.get(0)), // who
					getUserName(tokens.get(0)), // username
					getHostName(tokens.get(0)), // host name
					session.getChannel(tokens.get(2).data).getName(), // channel name
					session.getChannel(tokens.get(2).data), 
					partMsg 
			);
	}
		

	// :raving!n=raving@74.195.43.119 NICK :Sir_Fawnpug
	public static NickChangeEvent nickChange(EventToken token, IRCEvent event)
	{
			List<Token> tokens = token.getWordTokens();
			Session session = event.getSession();
			return new NickChangeEventImpl
			(
					token.getData(), 
					session, 
					getNick(tokens.get(0)), // old
					tokens.get(2).data.substring(1), // new nick
				getHostName(tokens.get(0)), // hostname
				getUserName(tokens.get(0)) // username
		); 
	}

	// :r0bby!n=wakawaka@guifications/user/r0bby INVITE scripy1 :#jerklib2
	public static InviteEvent invite(EventToken token, IRCEvent event)
	{
		String data = token.getData();
		Pattern p = Pattern.compile("^:(\\S+?)!(\\S+?)@(\\S+)\\s+INVITE.+?:(.*)$");
		Matcher m = p.matcher(data);
		if (m.matches()) { return new InviteEventImpl(m.group(4).toLowerCase(), m.group(1), m.group(2), m.group(3), data, event.getSession()); }
		debug("INVITE", data);
		return null;
	}

	private static void debug(String method, String data)
	{
		if (!ConnectionManager.debug) { return; }
		log.info("Returning null from " + method + " in IRCEventFactory. Offending data:");
		log.info(data);
	}

	static Logger log = Logger.getLogger(IRCEventFactory.class.getName());
}










